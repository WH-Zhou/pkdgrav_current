# command to run pkdgrav
pkdgrav ss.par > output 2>&1 &

# parameters in ss.par
iOutInterval		# general output file interval in timesteps
iRedOutInterval	        # reduced-output interval in timesteps
dDelta  # time step
nSteps  # number of total timesteps..
bDoGravity	= 1		# include gravity (interparticle + external)?
bDoSelfGravity	= 1		# include interparticle gravity?
bHeliocentric	= 0		# use "heliocentric" reference frame?


# Procedure for simulation
patchic.par: Orbital distance; Dynamical optical dept; Patch dimensions; Velocity limits
ssdraw.par: Patch width; Patch length; View size
ss.par: dDelta; nSteps; dCentMass; dxPeriod; dyPeriod; dOrbDist

If change optical depth tau, then Sigma change -> lambda_crit
(1) patchic.par (Dynamical optical depth; Patch dimensions; Velocity limit)
(2) ssdraw.par (Patch width; Patch length; View size; Orbital frequency)
(3) ss.par (dxPeriod; dyPeriod)

If change orbital radius but fix the height, then omega_orb changes -> lambda_crit
(1) patchic.par (Orbital distance; Patch dimensions; Velocity limit)
(2) ssdraw.par (Patch width; Patch length; View size)
(3) ss.par (dOrbDist; dxPeriod; dyPeriod)
Also, orbit_speed change -> theoretical_collision_speed -> vx, vy, vz  -> the timestep 
(1) ss.par (dDelta)

If change the optical depth tau, then Sigma changes
(1) ssdraw.par (Patch width; Patch length; View size)
(2) ss.par (dxPeriod; dyPeriod)



# command to generate the patch, according to patchic.par
patchgen  

# command to run the movie
python3 generate_movie.py 0(start index) 50000(end index) 1000(step) 0.1(duration) test_movie(output name)

# source file for patch
patchgen.c

# plot by paraview
cd planetary_ring
python3 ss_to_vtp_batch_with_pvd.py results/tau_0_3_R_3 0 330000 1000
open .pvd file via paraview
filter -> glyph

# ssdraw
The camera postion should be larger than the length of the box, but cannot be too large. The best location could be 2l~ 20 l. They actually look the same. If larger, the particle size is not real. If smaller, the particles warp.

camera position = 0 0 1e-8      # Camera 10 units above the patch in Z
sky vector = 0 1 0            # Y axis points "up" in the image

The ghost color in ssdraw is the color assigned to replicated particles (in replicated patches), not the original particles.

To make the particle size corrent:
Camera position		0 0 1e-8	! Abs or rel coords in length units or radii*



To avoid overlap with ghost particles:
Patch width		-Lx	! In AU (or -ve for mks units)
Patch length		-Lx	! Ditto

To set the frame in a good size:
Starting view size	= Lx or Ly * 3	! In length units (-ve for mks units; 0=min)



# Modify patchgen.c

1. add a line in patchic.par: Particle color  8
2. in the file patchgen.c:
define the parameter
"typedef struct {
  ...
  int iParticleColor;  // <-- add this line if it's not already present
  ...
} PARAMS;"

read the input
"ReadInt("Particle density distribution",&p->bDensDist);
assert(p->iParticleColor >= 0 && p->iParticleColor <= 255);"

use the value
"data.color = p->iParticleColor;"

3. make






# optical depth calculation

tau = n * sigma * h, where n is the number density, h is the height, sigma is geometric cross section.

tau = 3 * Sigma / rho / r / 4, where Sigma is surface mass density in kg/m^2, rho is particle density and r is the particle radius.

This comes from n = Sigma / 2 / h / rho / V, and sigma = pi * r^2.


# total number of particles
Due to tau = N_total * sigma * h / V
N_total = tau * V / sigma / h = tau * Lx * Ly / sigma
since sigma = pi * r^2, Lx = Ly = 4 * lambda_crit = 4 * 4 * pi * G * Sigma / Omega^2
N_total = tau * 16^2 * pi^2 * G^2 * Sigma^2 / Omega^4 /  (pi * r^2).
Substituting Sigma = 4 * tau * r * rho / 3,
N_total = tau * 16^2 * pi^2 * G^2 * 16/9 * tau^2 * rho^2 * r^2 / Omega^4 /  (pi * r^2)
= 16^3/9 * pi * G^2 * tau^3 * rho^2 / Omega^4.

It is independent of the particle size r, but proportional to tau^3, rho^2 and Omega^(-4) or a^6. 


# spin velocity
Spins are taken to be in the rotating frame.
This means particles initially with zero spin
actually have space z-spins of Omega, such that
they always show the same face to the planet


# velocity

MaxV — Uniform Distribution
Particles get random velocities within a box bounded by [-vMax, +vMax] in each direction:
v = (2 * rand() -1 ) * v_max

DispV — Gaussian Distribution
Velocities are drawn from a normal distribution centered at 0 with width σ = vVelLim:
v = N(0, v_max)

WgtDispV — Weighted Gaussian (Mass-dependent)
Same as above, but scaled to ensure more massive particles have proportionally smaller velocity dispersions:
v = N(0, v_max) * np.sqrt(M_mean/M)















# Errors & Solutions

1. DEM ERROR #1 (pid=0,T=0) fatal overlap: 431 & 622, 68.029635% of smaller radius (relative v = 7.44246e-08)
Assertion failed: (iWarningType != DEM_ERROR), function DoDEM, file smoothfcn.c, line 4580.
SOLUTION: change "Patch dimensions" in patchic.par from "30 30 10" to "10 10 10" 





