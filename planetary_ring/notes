# parameters in ss.par
iOutInterval		# general output file interval in timesteps
iRedOutInterval	        # reduced-output interval in timesteps
dDelta  # time step
nSteps  # number of total timesteps..

# command to run pkdgrav
pkdgrav ss.par > output 2>&1 &

# command to generate the patch, according to patchic.par
patchgen  

# command to run the movie
python3 generate_movie.py 0(start index) 50000(end index) 1000(step) 0.1(duration) test_movie(output name)

# source file for patch
patchgen.c

# ssdraw
The camera postion should be larger than the length of the box, but cannot be too large. The best location could be 2l~ 20 l. They actually look the same. If larger, the particle size is not real. If smaller, the particles warp.

camera position = 0 0 1e-8      # Camera 10 units above the patch in Z
sky vector = 0 1 0            # Y axis points "up" in the image

The ghost color in ssdraw is the color assigned to replicated particles (in replicated patches), not the original particles.

To make the particle size corrent:
Camera position		0 0 1e-8	! Abs or rel coords in length units or radii*

To set the frame in a good size:
Starting view size	-150	! In length units (-ve for mks units; 0=min)

To avoid overlap with ghost particles:
Patch width		-100	! In AU (or -ve for mks units)
Patch length		-100	! Ditto



# Modify patchgen.c

1. add a line in patchic.par: Particle color  8
2. in the file patchgen.c:
define the parameter
"typedef struct {
  ...
  int iParticleColor;  // <-- add this line if it's not already present
  ...
} PARAMS;"

read the input
"ReadInt("Particle density distribution",&p->bDensDist);
assert(p->iParticleColor >= 0 && p->iParticleColor <= 255);"

use the value
"data.color = p->iParticleColor;"

3. make






# optical depth calculation

tau = n * sigma * h, where n is the number density, h is the height, sigma is geometric cross section.

tau = 3 * Sigma / rho / r / 4, where Sigma is surface mass density in kg/m^2, rho is particle density and r is the particle radius.

This comes from n = Sigma / 2 / h / rho / V, and sigma = pi * r^2.


# total number of particles
Due to tau = N_total * sigma * h / V
N_total = tau * V / sigma / h = tau * Lx * Ly / sigma
since sigma = pi * r^2, Lx = Ly = 4 * lambda_crit = 4 * 4 * pi * G * Sigma / Omega^2
N_total = tau * 16^2 * pi^2 * G^2 * Sigma^2 / Omega^4 /  (pi * r^2).
Substituting Sigma = 4 * tau * r * rho / 3,
N_total = tau * 16^2 * pi^2 * G^2 * 16/9 * tau^2 * rho^2 * r^2 / Omega^4 /  (pi * r^2)
= 16^3/9 * pi * G^2 * tau^3 * rho^2 / Omega^4.

It is independent of the particle size r, but proportional to tau^3, rho^2 and Omega^(-4) or a^6. 


# spin velocity
Spins are taken to be in the rotating frame.
This means particles initially with zero spin
actually have space z-spins of Omega, such that
they always show the same face to the planet


# velocity

MaxV — Uniform Distribution
Particles get random velocities within a box bounded by [-vMax, +vMax] in each direction:
v = (2 * rand() -1 ) * v_max

DispV — Gaussian Distribution
Velocities are drawn from a normal distribution centered at 0 with width σ = vVelLim:
v = N(0, v_max)

WgtDispV — Weighted Gaussian (Mass-dependent)
Same as above, but scaled to ensure more massive particles have proportionally smaller velocity dispersions:
v = N(0, v_max) * np.sqrt(M_mean/M)





# Procedure for simulation


ss.par: dDelta; nSteps; dCentMass; dxPeriod; dyPeriod; dOrbDist





